# src/db/chroma_manager.py
"""
Robust ChromaDB Manager
Handles both local persistent and server-based ChromaDB setups.
"""

import chromadb
from chromadb.config import Settings
from datetime import datetime, timezone

from typing import Optional, List, Dict
import os

# ‚úÖ use the shared embedding service instead of our own SentenceTransformer
from .embeddings import embedding_service  # singleton EmbeddingService :contentReference[oaicite:4]{index=4}


class ChromaDBManager:
    """Singleton manager for ChromaDB operations."""
    
    _instance = None
    _client = None
    _collection = None
    
    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance
    
    def __init__(self):
        """Initialize ChromaDB client."""
        if self._client is None:
            self._initialize_client()
    
    def _initialize_client(self):
        """Initialize ChromaDB client with proper configuration."""
        try:
            # Try local persistent mode first
            db_path = "./data/chroma_db"
            os.makedirs(db_path, exist_ok=True)
            
            self._client = chromadb.PersistentClient(
                path=db_path,
                settings=Settings(
                    anonymized_telemetry=False,
                    allow_reset=True
                )
            )
            print(f"ChromaDB initialized in persistent mode: {db_path}")
            
        except RuntimeError as e:
            if "http-only client mode" in str(e):
                print("ChromaDB HTTP-only client detected.")
                print("Please run: pip uninstall chromadb chromadb-client && pip install chromadb")
                raise RuntimeError(
                    "ChromaDB is in HTTP-only mode. Install full ChromaDB:\n"
                    "  pip uninstall chromadb chromadb-client\n"
                    "  pip install chromadb"
                )
            raise
    
    def get_collection(self, collection_name: str = "translator_articles"):
        """Get or create a collection."""
        if self._collection is None or self._collection.name != collection_name:
            self._collection = self._client.get_or_create_collection(
                name=collection_name,
                metadata={"description": "Articles for translator training"}
            )
        return self._collection
    
    # ---------- Embedding helpers using EmbeddingService ----------
    
    def embed_text(self, text: str) -> List[float]:
        """Generate normalized embeddings for text using the shared EmbeddingService."""
        emb = embedding_service.embed(text)  # returns np.ndarray :contentReference[oaicite:5]{index=5}
        # Ensure 1D list of floats
        import numpy as np
        if isinstance(emb, list):
            emb = emb[0]
        return np.asarray(emb, dtype="float32").tolist()
    
    def embed_batch(self, texts: List[str]) -> List[List[float]]:
        """Generate embeddings for multiple texts."""
        embs = embedding_service.embed_batch(texts)  # np.ndarray shape (n, d) :contentReference[oaicite:6]{index=6}
        return [row.tolist() for row in embs]
    
    # ---------- Duplicate check ----------
    
    def is_duplicate(self, text: str, threshold: float = 0.85) -> bool:
        """
        Check if similar content exists in database.
        Returns True if similarity > threshold.
        """
        collection = self.get_collection()
        
        if collection.count() == 0:
            return False
        
        embedding = self.embed_text(text)
        results = collection.query(
            query_embeddings=[embedding],
            n_results=1
        )
        
        if not results["distances"] or len(results["distances"][0]) == 0:
            return False
        
        # ChromaDB returns distance (lower = more similar)
        distance = results["distances"][0][0]
        similarity = 1 - distance
        
        print(f"  Similarity with existing content: {similarity:.3f}")
        
        return similarity > threshold
    
    # ---------- Add article (unified ID) ----------
    
   

    def add_article(
        self,
        title: str,
        content: str,
        topic: str,
        vocab_summary: str,
        author: str,
        article_id: str,   # REQUIRED
    ) -> str:
        """
        Store an article using a unified article_id generated by StorageService.
        Chroma will NEVER generate its own ID anymore.
        """

        # --- Validation ---
        if not article_id:
            raise ValueError("article_id is required ‚Äî ChromaManager cannot generate IDs.")

        # --- Get collection ---
        collection = self.get_collection()

        # --- Embedding ---
        embedding = self.embed_text(content)

        # --- Metadata ---
        metadata = {
            "article_id": article_id,
            "title": title,
            "topic": topic,
            "vocab_summary": vocab_summary,
            "author": author,
            "created_at": datetime.now(timezone.utc).isoformat(),
            "word_count": len(content.split()),
        }

        # --- Save to Chroma ---
        collection.add(
            ids=[article_id],
            documents=[content],
            metadatas=[metadata],
            embeddings=[embedding],
        )

        return article_id


        
        # ---------- Search & metadata ----------
        
    def search_similar(
            self, 
            query: str, 
            n_results: int = 5,
            filter_topic: Optional[str] = None
        ) -> List[Dict]:
            """
            Search for similar articles using semantic search.
            """
            collection = self.get_collection()
            
            if collection.count() == 0:
                return []
            
            # Prepare filter
            where_filter = {"topic": filter_topic} if filter_topic else None
            
            # Generate query embedding
            query_embedding = self.embed_text(query)
            
            # Search
            results = collection.query(
                query_embeddings=[query_embedding],
                n_results=n_results,
                where=where_filter
            )
            
            # Format results
            articles = []
            if results["documents"]:
                for i in range(len(results["documents"][0])):
                    articles.append({
                        "id": results["ids"][0][i],
                        "content": results["documents"][0][i],
                        "metadata": results["metadatas"][0][i],
                        "similarity": 1 - results["distances"][0][i]
                    })
            
            return articles
        
    def get_all_topics(self) -> List[str]:
            """Get list of all unique topics in database."""
            collection = self.get_collection()
            
            if collection.count() == 0:
                return []
            
            results = collection.get()
            topics = set()
            
            for metadata in results["metadatas"]:
                if "topic" in metadata:
                    topics.add(metadata["topic"])
            
            return sorted(list(topics))
        
    def delete_article(self, doc_id: str) -> bool:
        """Delete article by ID."""
        collection = self.get_collection()
        try:
            collection.delete(ids=[doc_id])
            print(f"  Deleted article: {doc_id}")
            return True
        except Exception as e:
            print(f"  Failed to delete {doc_id}: {e}")
            return False

    # -------------------------
    # COLLECTION RESET (for tests)
    # -------------------------
    def reset_collection(self, collection_name: str = "translator_articles"):
        """
        Delete a ChromaDB collection completely and recreate it.
        Useful for tests and development tools.
        """
        try:
            self._client.delete_collection(name=collection_name)
            print(f"üóëÔ∏è Deleted Chroma collection: {collection_name}")
        except Exception as e:
            print(f"‚ö†Ô∏è Could not delete collection '{collection_name}': {e}")

        self._collection = None
        self.get_collection(collection_name)










# Singleton instance
chroma_manager = ChromaDBManager()
